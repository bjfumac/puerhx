{{
const fixGet = {
    char: 'GetChar',
    sbyte: 'GetSByte',
    byte: 'GetByte',
    short: 'GetInt16',
    ushort: 'GetUInt16',
    int: 'GetInt32',
    uint: 'GetUInt32',
    long: 'GetInt64',
    ulong: 'GetUInt64',
    double: 'GetDouble',
    float: 'GetFloat',
    bool: 'GetBoolean',
    string: 'GetString',
    DateTime: 'GetDateTime',
};
const fixReturn = {
    char: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    sbyte: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    byte: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    short: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    ushort: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    int: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    uint: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    long: 'Puerts.PuertsDLL.ReturnBigInt(isolate, info, result)',
    ulong: 'Puerts.PuertsDLL.ReturnBigInt(isolate, info, (long)result)',
    double: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    float: 'Puerts.PuertsDLL.ReturnNumber(isolate, info, result)',
    bool: 'Puerts.PuertsDLL.ReturnBoolean(isolate, info, result)',
    string: 'Puerts.PuertsDLL.ReturnString(isolate, info, result)',
    DateTime: 'Puerts.PuertsDLL.ReturnDate(isolate, info, (result - new DateTime(1970, 1, 1)).TotalMilliseconds)',
};
const operatorMap = {
    op_Equality: '==',
    op_Inequality: '!=',
    op_GreaterThan: '>',
    op_LessThan: '<',
    op_GreaterThanOrEqual: '>=',
    op_LessThanOrEqual: '<=',
    op_BitwiseAnd: '&',
    op_BitwiseOr: '|',
    op_Addition: '+',
    op_Subtraction: '-',
    op_Division: '/',
    op_Modulus: '%',
    op_Multiply: '*',
    op_LeftShift: '<<',
    op_RightShift: '>>',
    op_ExclusiveOr: '^',
    op_UnaryNegation: '-',
    op_UnaryPlus: '+',
    op_LogicalNot: '!',
    op_OnesComplement: '~',
    op_False: '',
    op_True: '',
    op_Increment: '++',
    op_Decrement: '--',
};
let csharpKeywords = {};
[
    "abstract", "as", "base", "bool",
    "break", "byte", "case", "catch",
    "char", "checked", "class", "const",
    "continue", "decimal", "default", "delegate",
    "do", "double", "else", "enum",
    "event", "explicit", "extern", "false",
    "finally", "fixed", "float", "for",
    "foreach", "goto", "if", "implicit",
    "in", "int", "interface",
    "internal", "is", "lock", "long",
    "namespace", "new", "null", "object",
    "operator", "out", "override",
    "params", "private", "protected", "public",
    "readonly", "ref", "return", "sbyte",
    "sealed", "short", "sizeof", "stackalloc",
    "static", "string", "struct", "switch",
    "this", "throw", "true", "try",
    "typeof", "uint", "ulong", "unchecked",
    "unsafe", "ushort", "using", "virtual",
    "void", "volatile", "while"
].forEach(keywold => {
    csharpKeywords[keywold] = '@' + keywold;
});

function UnK(identifier) {
    return csharpKeywords[identifier] || identifier
}

function getArgument(typeInfo, argHelper, idx) {
    let typeName = typeInfo.TypeName;
    let isByRef = typeInfo.IsByRef ? "true" : "false";
    if (typeInfo.IsParams) {
        return `${argHelper}.GetParams<${typeName}>(info, ${idx}, paramLen)`;
    } else if (typeInfo.IsEnum) {
        return `(${typeName})${argHelper}.${fixGet[typeInfo.UnderlyingTypeName]}(${isByRef})`;
    } else if (typeName in fixGet) {
        return `${argHelper}.${fixGet[typeName]}(${isByRef})`;
    } else {
        return `${argHelper}.Get<${typeName}>(${isByRef})`;
    }
}
function setReturn(typeInfo) {
    let typeName = typeInfo.TypeName;
    if (typeName in fixReturn) {
        return fixReturn[typeName];
    } else if (typeInfo.IsEnum) {
        return fixReturn[typeInfo.UnderlyingTypeName].replace('result', `(${typeInfo.UnderlyingTypeName})result`);
    } else {
        return `Puerts.ResultHelper.Set((int)data, isolate, info, result)`;
    }
}
function operatorCall(methodName, argCount, typeInfo) {
    if (methodName == 'op_Implicit') {
        return `(${typeInfo.TypeName})arg0`;
    }
    if (argCount == 1) {
        return operatorMap[methodName] + 'arg0';
    } else if (argCount == 2) {
        return 'arg0 ' + operatorMap[methodName] + ' arg1';
    }
}

function getSelf(type) {
    if (type.IsValueType) {
        return `(${type.Name})Puerts.Utils.GetSelf((int)data, self)`;
    } else if (it.BlittableCopy) {
        return `*(${type.Name}*)self`;
    } else {
        return `Puerts.Utils.GetSelf((int)data, self) as ${type.Name}`;
    }
}

function toLowercase(str){
    return str.toLowerCase();
}
function getClassName(fullClassName){
    return fullClassName.substr(fullClassName.lastIndexOf(".") + 1);
}
function getNamespace(fullClassName){
    var idx = fullClassName.lastIndexOf(".");
    if(idx == -1){
        return "";
    }
    return fullClassName.slice(0, idx);
}
function getFunctionParams(infos){
    var ary = [];
    for(var i = 0;  i< infos.length;i++){
        ary.push(infos[i].Name+":"+getHaxeFullClassName(infos[i].TypeName));
    }
    return ary.join(",");
}

function getHaxeFullClassName(fullClassName){ 
    if(fullClassName.indexOf("<") != -1) return fullClassName;
    var namespace = getNamespace(fullClassName);
    var typeName = getClassName(fullClassName);
    if(namespace == null || namespace == ""){
        return typeName;
    }
    else{
        return "csharp." + toLowercase(namespace) + "." + typeName;
    }
}

}}
package csharp.{{=toLowercase(getNamespace(it.FullName))}};
@:jsRequire("csharp", "{{=it.FullName}}") extern class {{=getClassName(it.FullName)}}{{?it.BaseType != null}} extends {{=getHaxeFullClassName(it.BaseType)}}{{?}} {
    {{?it.Constructor}}public function new();{{?}}
    {{~it.Properties :properties}}
	public {{?properties.IsStatic}}static {{?}}var {{=properties.Name}}:{{=getHaxeFullClassName(properties.TypeName)}};
	{{~}}
	{{~it.Methods :method}}
        {{~method.OverloadGroups :overloadGroup:idx}}
            {{~overloadGroup :overload:idx1}}
                {{?!(idx ==0 && idx1 == 0)}}
                    @:overload(function({{=getFunctionParams(overload.ParameterInfos)}}
                    ):{{=getHaxeFullClassName(overload.TypeName)}} {})
                {{?}}
            {{~}}
            
        {{~}}
        public {{?method.IsStatic}}static{{?}} function {{=method.Name}}({{=getFunctionParams(method.OverloadGroups[0][0].ParameterInfos)}}):{{=getHaxeFullClassName(method.OverloadGroups[0][0].TypeName)}};
    {{~}}
    
    
}
